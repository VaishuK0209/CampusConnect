const express = require('express');
const fetch = global.fetch || require('node-fetch');
const router = express.Router();
const db = require('../utils/db');

// Grammar check via LanguageTool public API
router.post('/ai/grammar', async (req, res) => {
  try {
    const { text } = req.body || {};
    if (!text) return res.status(400).json({ error: 'text required' });
    const params = new URLSearchParams();
    params.append('text', text);
    params.append('language', 'en-US');
    const resp = await fetch('https://api.languagetool.org/v2/check', { method: 'POST', body: params });
    const data = await resp.json();
    return res.json(data);
  } catch (err) {
    console.error('grammar err', err);
    res.status(500).json({ error: 'Server error' });
  }
});

// Summary: use OpenAI if key present, else fallback simple extractor
router.post('/ai/summary', async (req, res) => {
  try {
    const { text } = req.body || {};
    if (!text) return res.status(400).json({ error: 'text required' });
    const key = process.env.OPENAI_API_KEY;
    if (key) {
      const prompt = `Write a concise summary (3-5 sentences) of the following text:\n\n${text}`;
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${key}` },
        body: JSON.stringify({ model: 'gpt-3.5-turbo', messages: [{ role: 'user', content: prompt }], max_tokens: 250 })
      });
      const data = await resp.json();
      const summary = (data?.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || '';
      return res.json({ summary, raw: data });
    }
    // fallback: simple extractive summary: first 3 sentences
    const sentences = (text.replace(/\n+/g,' ').match(/[^.!?]+[.!?]*/g) || []);
    const summary = sentences.slice(0,3).join(' ').trim();
    return res.json({ summary, raw: null });
  } catch (err) {
    console.error('summary err', err);
    res.status(500).json({ error: 'Server error' });
  }
});

// AI-detection: uses OpenAI if available, else heuristic score
router.post('/ai/detect', async (req, res) => {
  try {
    const { text } = req.body || {};
    if (!text) return res.status(400).json({ error: 'text required' });
    const key = process.env.OPENAI_API_KEY;
    if (key) {
      const prompt = `Decide whether the following text is generated by AI or written by a human. Respond with a JSON object {"verdict": "AI"|"Human", "confidence": <0-1>, "explanation": "..."} :\n\n${text}`;
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${key}` },
        body: JSON.stringify({ model: 'gpt-3.5-turbo', messages: [{ role: 'user', content: prompt }], max_tokens: 200 })
      });
      const data = await resp.json();
      const content = (data?.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || '';
      // try parse JSON from model response
      let parsed = { verdict: 'unknown', confidence: 0, explanation: content };
      try { parsed = Object.assign(parsed, JSON.parse(content)); } catch (e) { parsed.explanation = content; }
      return res.json({ result: parsed, raw: data });
    }

    // Fallback heuristic detection
    const words = text.split(/\s+/).filter(Boolean);
    const totalWords = words.length || 1;
    const uniqueWords = new Set(words.map(w => w.toLowerCase().replace(/[^a-z]/g,''))).size;
    const uniqueRatio = uniqueWords / totalWords;
    const avgSentenceLen = (text.match(/[^.!?]+[.!?]*/g) || []).reduce((s, a) => s + a.split(/\s+/).filter(Boolean).length, 0) / Math.max(1, (text.match(/[^.!?]+[.!?]*/g) || []).length);
    // repetition metric
    const freq = {};
    for (const w of words) { const k = w.toLowerCase().replace(/[^a-z]/g,''); if (!k) continue; freq[k] = (freq[k]||0)+1; }
    const maxFreq = Math.max(...Object.values(freq), 0);
    const repetition = maxFreq / totalWords;
    // heuristic score: higher when less unique, longer sentences, more repetition
    let score = (1 - uniqueRatio) * 0.6 + Math.min(avgSentenceLen / 25, 1) * 0.25 + Math.min(repetition, 1) * 0.15;
    score = Math.max(0, Math.min(1, score));
    const verdict = score > 0.5 ? 'AI' : 'Human';
    return res.json({ result: { verdict, confidence: score, details: { uniqueRatio, avgSentenceLen, repetition } } });
  } catch (err) {
    console.error('detect err', err);
    res.status(500).json({ error: 'Server error' });
  }
});

module.exports = router;
